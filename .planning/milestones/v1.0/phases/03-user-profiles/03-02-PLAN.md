---
phase: 03-user-profiles
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified: [app/convex/permissions.ts, app/convex/lib/roles.ts]
autonomous: true
---

<objective>
Define role hierarchy and permission system for content access control.

Purpose: Establish clear permissions for admin, manager, and staff roles.
Output: Permission definitions, role utilities, permission check functions.
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/03-user-profiles/03-01-SUMMARY.md
@app/convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define role constants and hierarchy</name>
  <files>app/convex/lib/roles.ts</files>
  <action>
Create `convex/lib/roles.ts`:

```typescript
// Role definitions for Silver Sycamore Staff Hub
export const ROLES = {
  ADMIN: "admin",
  MANAGER: "manager",
  STAFF: "staff",
} as const;

export type Role = (typeof ROLES)[keyof typeof ROLES];

// Role hierarchy (higher index = more permissions)
export const ROLE_HIERARCHY: Role[] = ["staff", "manager", "admin"];

// Check if roleA has at least the permissions of roleB
export function hasRoleLevel(userRole: Role, requiredRole: Role): boolean {
  const userLevel = ROLE_HIERARCHY.indexOf(userRole);
  const requiredLevel = ROLE_HIERARCHY.indexOf(requiredRole);
  return userLevel >= requiredLevel;
}

// Permission actions
export const ACTIONS = {
  VIEW_CONTENT: "view_content",
  EDIT_CONTENT: "edit_content",
  DELETE_CONTENT: "delete_content",
  MANAGE_USERS: "manage_users",
  VIEW_ANALYTICS: "view_analytics",
} as const;

export type Action = (typeof ACTIONS)[keyof typeof ACTIONS];

// Role-action mapping
export const ROLE_PERMISSIONS: Record<Role, Action[]> = {
  staff: ["view_content"],
  manager: ["view_content", "edit_content", "view_analytics"],
  admin: ["view_content", "edit_content", "delete_content", "manage_users", "view_analytics"],
};

export function canPerform(role: Role, action: Action): boolean {
  return ROLE_PERMISSIONS[role]?.includes(action) ?? false;
}
```
  </action>
  <verify>Types and utilities defined</verify>
  <done>Role definitions created</done>
</task>

<task type="auto">
  <name>Task 2: Create permissions.ts with server-side checks</name>
  <files>app/convex/permissions.ts</files>
  <action>
Create `convex/permissions.ts` with helper functions:

```typescript
import { QueryCtx, MutationCtx } from "./_generated/server";
import { Role, Action, canPerform, hasRoleLevel } from "./lib/roles";

// Get current user's role from profile
export async function getCurrentUserRole(
  ctx: QueryCtx | MutationCtx
): Promise<Role | null> {
  const identity = await ctx.auth.getUserIdentity();
  if (!identity) return null;

  const user = await ctx.db
    .query("users")
    .filter((q) => q.eq(q.field("email"), identity.email))
    .first();

  if (!user) return null;

  const profile = await ctx.db
    .query("userProfiles")
    .withIndex("by_userId", (q) => q.eq("userId", user._id))
    .first();

  return (profile?.role as Role) ?? "staff";
}

// Check if current user can perform action
export async function canUserPerform(
  ctx: QueryCtx | MutationCtx,
  action: Action
): Promise<boolean> {
  const role = await getCurrentUserRole(ctx);
  if (!role) return false;
  return canPerform(role, action);
}

// Assert permission or throw
export async function assertPermission(
  ctx: QueryCtx | MutationCtx,
  action: Action
): Promise<void> {
  const canDo = await canUserPerform(ctx, action);
  if (!canDo) {
    throw new Error(`Permission denied: ${action}`);
  }
}

// Check if current user has at least required role level
export async function hasRequiredRole(
  ctx: QueryCtx | MutationCtx,
  requiredRole: Role
): Promise<boolean> {
  const role = await getCurrentUserRole(ctx);
  if (!role) return false;
  return hasRoleLevel(role, requiredRole);
}
```
  </action>
  <verify>Permission helpers working</verify>
  <done>permissions.ts created</done>
</task>

<task type="auto">
  <name>Task 3: Add admin user setup</name>
  <files>app/convex/users.ts</files>
  <action>
Add an admin setup mutation that can only be run once (first user becomes admin):

```typescript
// In users.ts, add:
export const makeFirstUserAdmin = mutation({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");

    // Check if any admin exists
    const existingAdmin = await ctx.db
      .query("userProfiles")
      .withIndex("by_role", (q) => q.eq("role", "admin"))
      .first();

    if (existingAdmin) {
      throw new Error("Admin already exists");
    }

    // Get current user
    const user = await ctx.db
      .query("users")
      .filter((q) => q.eq(q.field("email"), identity.email))
      .first();

    if (!user) throw new Error("User not found");

    // Get their profile
    const profile = await ctx.db
      .query("userProfiles")
      .withIndex("by_userId", (q) => q.eq("userId", user._id))
      .first();

    if (profile) {
      await ctx.db.patch(profile._id, { role: "admin", updatedAt: Date.now() });
    }

    return { success: true };
  },
});
```
  </action>
  <verify>First user can become admin</verify>
  <done>Admin setup mutation added</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] lib/roles.ts with constants and helpers
- [ ] permissions.ts with server-side checks
- [ ] Admin setup mutation works
- [ ] Convex dev syncs
</verification>

<success_criteria>
- Clear role hierarchy defined
- Permission checks available for Convex functions
- First user can become admin
</success_criteria>

<output>
After completion, create `.planning/phases/03-user-profiles/03-02-SUMMARY.md`
</output>
